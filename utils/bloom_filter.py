import math
import hashlib
from typing import Iterator, Union

class BloomFilter:
    """
    A probabilistic data structure that efficiently tests whether an element is a member of a set.
    
    False positives are possible (stating an element is in the set when it is not), 
    but false negatives are not (stating an element is not in the set when it is).
    """
    
    def __init__(self, capacity: int, error_rate: float = 0.001):
        """
        Initialize the Bloom Filter.

        Args:
            capacity (int): The expected number of elements (n) to be added.
            error_rate (float): The acceptable false positive probability (p). Default is 0.1%.
        """
        self.capacity = capacity
        self.error_rate = error_rate
        
        # Calculate size of bit array (m)
        # Formula: m = -(n * ln(p)) / (ln(2)^2)
        self.size = int(-(capacity * math.log(error_rate)) / (math.log(2) ** 2))
        
        # Calculate optimal number of hash functions (k)
        # Formula: k = (m / n) * ln(2)
        self.hash_count = int((self.size / capacity) * math.log(2))
        
        # Initialize bit array.
        # Python handles large integers automatically, effectively acting as a bitfield.
        # This is more memory efficient than a list of booleans for sparse data.
        self.bit_array = 0
        
        print(f"BloomFilter Initialized: Capacity={capacity}, Size={self.size} bits, HashFuncs={self.hash_count}")

    def _hashes(self, item: Union[str, bytes]) -> Iterator[int]:
        """
        Generates k hash values for the given item using the Double Hashing technique.
        
        Double Hashing helps in minimizing collisions without computing k independent hash functions.
        Formula: hash_i = (hash1 + i * hash2) % size

        Args:
            item (Union[str, bytes]): The item to be hashed.

        Yields:
            int: The next hash index in the sequence.
        """
        if isinstance(item, str):
            item_bytes = item.encode('utf-8')
        else:
            item_bytes = str(item).encode('utf-8')
        
        # We use SHA256 to generate a sufficiently large cryptographic hash.
        # Splitting it gives us two independent 32-bit integers (h1 and h2) needed for double hashing.
        digest = hashlib.sha256(item_bytes).digest()
        
        # h1: First 4 bytes (Big Endian)
        h1 = int.from_bytes(digest[0:4], 'big')
        # h2: Next 4 bytes (Big Endian)
        h2 = int.from_bytes(digest[4:8], 'big')
        
        for i in range(self.hash_count):
            # Generate the ith hash index
            yield (h1 + i * h2) % self.size

    def add(self, item: Union[str, bytes]) -> None:
        """
        Add an item to the Bloom Filter.
        
        This sets the bits at the k positions generated by the hash functions to 1.
        
        Args:
            item (Union[str, bytes]): The item to add.
        """
        for hash_val in self._hashes(item):
            self.bit_array |= (1 << hash_val)

    def check(self, item: Union[str, bytes]) -> bool:
        """
        Check if an item is possibly in the Bloom Filter.

        Args:
            item (Union[str, bytes]): The item to check.

        Returns:
            bool: 
                True -> The item is PROBABLY in the set.
                False -> The item is DEFINITELY NOT in the set.
        """
        for hash_val in self._hashes(item):
            # If any of the bits is 0, the item was definitely not added.
            if not (self.bit_array & (1 << hash_val)):
                return False
        return True

    def __len__(self) -> int:
        """
        Estimate the number of elements currently in the filter.
        
        This uses the Swath-based approximation formula based on the density of 1s in the bit array.
        Formula: n* = -(m/k) * ln(1 - X/m)
        
        Returns:
            int: Estimated number of elements.
        """
        # Count the number of set bits (X)
        bits_set = bin(self.bit_array).count('1')
        
        if self.size == 0 or self.hash_count == 0:
            return 0
            
        # Avoid log(0) if fully saturated (unlikely but possible)
        if bits_set >= self.size:
            return self.capacity # Return approximate max capacity
            
        return int(-(self.size / self.hash_count) * math.log(1 - bits_set / self.size))
